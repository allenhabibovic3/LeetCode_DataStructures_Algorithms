//m-coloring print all solutions to the assignment of colors to the vertices of a graph, G
//time complexity is the sum of all the nodes visited that are generated by the state space tree
//backtracking gives us all the solutions
//time complexity: O(m^v+1) where = chromatic number, v = # of vertices
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;

class Edge {
	int src;
	int dest;
	
	public Edge(int src, int dest) {
		
		this.src = src;
		this.dest = dest;
		
	}
}

class Graph {
	List<List<Integer>> adj_list = null;
	
	public Graph(List<Edge> edges, int N) {
		this.adj_list = new ArrayList<>();
		
		for(int i = 0; i < N; i++) {
			this.adj_list.add(new ArrayList<>());
		}
		
		for(Edge e: edges) {
			int s = e.src;
			int d = e.dest;
			
			this.adj_list.get(s).add(d);
			this.adj_list.get(d).add(s);
		}
	}
}

public class NQueens {
	
	public static String[] COLORS = {"", "BLUE", "GREEN", "RED", "YELLOW", "ORANGE", "BLACK"};
	
	public static boolean isPromising(Graph G, int[] color, int v, int c) {
		for(int u: G.adj_list.get(v))
			if(color[u] == c)
				return false;
		
		return true;
	}
	
	public static void mColoring(Graph G, int[] color, int m, int v, int N) {
		
		if(v == N) {
			for(v = 0; v < N; v++)
				System.out.print(COLORS[color[v]] + " ");
			System.out.println();
			
			return;
		}
		
		for(int c = 1; c <= m; c++) {
			if(isPromising(G, color, v, c)) {
				color[v] = c;
				mColoring(G, color, m, v+1, N);
				color[v] = 0;
			}
		}
	}
	
	public static void main(String[] args) {
		
		List<Edge> edges = Arrays.asList(
                new Edge(0, 1), new Edge(0, 4),
                new Edge(0, 5), new Edge(4, 5),
                new Edge(1, 4), new Edge(1, 3),
                new Edge(2, 3), new Edge(2, 4)
        );
		
		int N = 6;
		int m = 3;
		int[] color = new int[N];
		Graph G = new Graph(edges, N);
		
		mColoring(G, color, m, 0, N);
	}
}
